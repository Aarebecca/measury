<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Text Width Browser Test</title>
  <link rel="stylesheet" href="fonts.css">
  <script src="font-mapping.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 20px;
    }
    
    h1 {
      color: #333;
      max-width: 1600px;
      margin: 0 auto 20px;
      font-size: 28px;
    }
    
    h2 {
      color: #333;
      font-size: 20px;
      margin-bottom: 15px;
    }
    
    .test-section {
      margin: 30px auto;
      padding: 20px;
      border: 1px solid #ddd;
      border-radius: 8px;
      max-width: 1600px;
    }
    
    /* ä¸¤æ å¸ƒå±€å®¹å™¨ */
    .two-column-layout {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      max-width: 1600px;
      margin: 30px auto;
    }
    
    .left-column, .right-column {
      min-width: 0; /* é˜²æ­¢å†…å®¹æº¢å‡º */
    }
    
    .preset-tests-section {
      padding: 20px;
      border: 1px solid #ddd;
      border-radius: 8px;
      height: 100%;
    }
    
    .preset-tests-section h2 {
      margin-top: 0;
      color: #333;
    }
    
    .code-output-section {
      padding: 20px;
      border: 1px solid #ddd;
      border-radius: 8px;
      background: #f5f5f5;
      height: 100%;
      position: sticky;
      top: 20px;
    }
    
    .code-output-section h2 {
      margin-top: 0;
      color: #333;
    }
    
    /* å“åº”å¼å¸ƒå±€ */
    @media (max-width: 1200px) {
      .two-column-layout {
        grid-template-columns: 1fr;
      }
    }
    
    .test-item {
      margin: 20px 0;
      padding: 15px;
      background: #f5f5f5;
      border-radius: 4px;
    }
    
    .measurement-box {
      display: inline-block;
      outline: 2px solid #4CAF50;
      background: #fff;
      position: relative;
    }
    
    .measurement-box::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      height: 1px;
      background: red;
      opacity: 0.5;
    }
    
    .results {
      margin-top: 10px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      color: #666;
    }
    
    .results div {
      margin: 5px 0;
    }
    
    .comparison {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
      padding: 10px;
      background: #fff;
      border-radius: 4px;
    }
    
    .comparison div {
      padding: 5px;
    }
    
    .comparison .label {
      font-weight: bold;
      color: #333;
    }
    
    .comparison .match {
      color: #4CAF50;
    }
    
    .comparison .mismatch {
      color: #f44336;
    }
    
    button {
      padding: 10px 20px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      margin: 10px 10px 10px 0;
    }
    
    button:hover {
      background: #45a049;
    }
    
    button.secondary {
      background: #2196F3;
    }
    
    button.secondary:hover {
      background: #0b7dda;
    }
    
    .code-actions {
      margin-bottom: 10px;
      display: flex;
      gap: 10px;
    }
    
    .copy-feedback {
      display: inline-block;
      margin-left: 10px;
      color: #4CAF50;
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .copy-feedback.show {
      opacity: 1;
    }
    
    #output {
      padding: 15px;
      background: #fff;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      white-space: pre-wrap;
      max-height: 600px;
      overflow-y: auto;
      font-size: 13px;
      line-height: 1.5;
      border: 1px solid #ddd;
    }
    
    #output:empty::before {
      content: 'è¿è¡Œæµ‹è¯•åï¼Œç”Ÿæˆçš„ä»£ç å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ...';
      color: #999;
      font-style: italic;
    }
    
    .test-case {
      margin: 10px 0;
      padding: 10px;
      background: #fff;
      border-left: 3px solid #2196F3;
      font-size: 14px;
    }
    
    .test-case h3 {
      margin-top: 0;
      font-size: 16px;
    }
    
    #testResults {
      max-height: 600px;
      overflow-y: auto;
    }
    
    #testResults:empty::before {
      content: 'ç‚¹å‡»"è¿è¡Œæ‰€æœ‰æµ‹è¯•"æŸ¥çœ‹ç»“æœ...';
      color: #999;
      font-style: italic;
    }
    
    .font-status {
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 4px;
      font-weight: bold;
    }
    
    .font-status.loading {
      background: #fff3cd;
      color: #856404;
      border: 1px solid #ffc107;
    }
    
    .font-status.loaded {
      background: #d4edda;
      color: #155724;
      border: 1px solid #28a745;
    }
    
    .font-status.error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #dc3545;
    }
  </style>
</head>
<body>
  <h1>Text Width æµè§ˆå™¨æµ‹è¯•å·¥å…·</h1>
  
  <!-- å­—ä½“åŠ è½½çŠ¶æ€ -->
  <div id="fontStatus" class="font-status loading">
    â³ æ­£åœ¨åŠ è½½å­—ä½“...
  </div>
  
  <div class="test-section">
    <h2>ä½¿ç”¨è¯´æ˜</h2>
    <p>1. é¡µé¢ä¼šè‡ªåŠ¨åŠ è½½ test-browser/fonts ç›®å½•ä¸‹çš„å­—ä½“æ–‡ä»¶</p>
    <p>2. åœ¨"è‡ªå®šä¹‰æµ‹è¯•"ä¸­é€‰æ‹©å­—ä½“å¹¶è¾“å…¥æ–‡æœ¬è¿›è¡Œæµ‹é‡</p>
    <p>3. ç»“æœä¼šæ˜¾ç¤ºæµè§ˆå™¨å®é™…æµ‹é‡çš„å®½åº¦ã€é«˜åº¦å’ŒåŸºçº¿å€¼</p>
    <p>4. ç‚¹å‡»"ç”Ÿæˆæµ‹è¯•ä»£ç "å¯ä»¥ç”Ÿæˆå¯¹åº”çš„æµ‹è¯•ç”¨ä¾‹ä»£ç ï¼Œä»£ç ä¸­ä¼šä½¿ç”¨å½“å‰é€‰æ‹©çš„å­—ä½“</p>
  </div>

  <div class="test-section">
    <h2>è‡ªå®šä¹‰æµ‹è¯•</h2>
    <div>
      <label>æ–‡æœ¬å†…å®¹ï¼š<input type="text" id="customText" value="Hello World" style="width: 300px; padding: 5px;"></label>
    </div>
    <div style="margin-top: 10px;">
      <label>å­—ä½“ï¼š
        <select id="customFont" style="width: 200px; padding: 5px;">
          <!-- å­—ä½“é€‰é¡¹å°†ç”± JavaScript åŠ¨æ€ç”Ÿæˆ -->
        </select>
      </label>
    </div>
    <div style="margin-top: 10px;">
      <label>å­—å·ï¼š<input type="number" id="customSize" value="16" style="width: 100px; padding: 5px;"> px</label>
    </div>
    <div style="margin-top: 10px;">
      <label>å­—é‡ï¼š
        <select id="customWeight" style="width: 100px; padding: 5px;">
          <option value="100">100 - Thin</option>
          <option value="200">200 - Extra Light</option>
          <option value="300">300 - Light</option>
          <option value="400" selected>400 - Regular</option>
          <option value="500">500 - Medium</option>
          <option value="600">600 - Semi Bold</option>
          <option value="700">700 - Bold</option>
          <option value="800">800 - Extra Bold</option>
          <option value="900">900 - Black</option>
        </select>
      </label>
    </div>
    <button onclick="testCustom()">æµ‹é‡</button>
    <button onclick="generateTestCodeFromCustom()">ç”Ÿæˆå½“å‰æµ‹è¯•ä»£ç </button>
    <div id="customResult"></div>
  </div>

  <!-- ä¸¤æ å¸ƒå±€ï¼šé¢„è®¾æµ‹è¯•å’Œä»£ç è¾“å‡º -->
  <div class="two-column-layout">
    <!-- å·¦ä¾§ï¼šé¢„è®¾æµ‹è¯•ç”¨ä¾‹ -->
    <div class="left-column">
      <div class="preset-tests-section">
        <h2>é¢„è®¾æµ‹è¯•ç”¨ä¾‹</h2>
        <div>
          <button onclick="runAllTests()">è¿è¡Œæ‰€æœ‰æµ‹è¯•</button>
          <button onclick="generateTestCode()">ç”Ÿæˆæ‰€æœ‰æµ‹è¯•ä»£ç </button>
        </div>
        <div id="testResults"></div>
      </div>
    </div>

    <!-- å³ä¾§ï¼šæµ‹è¯•ä»£ç è¾“å‡º -->
    <div class="right-column">
      <div class="code-output-section">
        <h2>æµ‹è¯•ä»£ç è¾“å‡º</h2>
        <div class="code-actions">
          <button class="secondary" onclick="copyOutputToClipboard()">ğŸ“‹ å¤åˆ¶ä»£ç </button>
          <span id="copyFeedback" class="copy-feedback">âœ“ å·²å¤åˆ¶!</span>
        </div>
        <div id="output"></div>
      </div>
    </div>
  </div>

  <script>
    // ç”Ÿæˆé»˜è®¤å­—ä½“æ˜ å°„
    function getDefaultFontMapping(fontName) {
      // ç§»é™¤å¼€å¤´çš„ä¸‹åˆ’çº¿ï¼Œç§»é™¤ä¸­é—´çš„ç©ºæ ¼
      const cleanName = fontName.replace(/\s+/g, '');
      const varName = cleanName.match(/^[_\d]/) ? '_' + cleanName : cleanName;
      return {
        displayName: fontName,
        varName,
        fileName: cleanName
      };
    }
    
    // è·å–å­—ä½“æ˜ å°„ï¼ˆä¼˜å…ˆä½¿ç”¨ fontMappingï¼Œå¦åˆ™ä½¿ç”¨é»˜è®¤è§„åˆ™ï¼‰
    function getFontMapping(fontName) {
      return fontMapping[fontName] || getDefaultFontMapping(fontName);
    }
    
    // ä» CSS ä¸­è§£æå­—ä½“åˆ—è¡¨
    async function loadAvailableFonts() {
      try {
        const response = await fetch('./fonts.css');
        const cssText = await response.text();
        
        // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æå–æ‰€æœ‰ font-family åç§°
        const fontFaceRegex = /@font-face\s*{[^}]*font-family:\s*['"]([^'"]+)['"]/g;
        const fonts = new Set();
        
        let match;
        while ((match = fontFaceRegex.exec(cssText)) !== null) {
          fonts.add(match[1]);
        }
        
        // å¡«å……å­—ä½“é€‰æ‹©æ¡†
        const fontSelect = document.getElementById('customFont');
        fontSelect.innerHTML = '';
        
        fonts.forEach(font => {
          const option = document.createElement('option');
          option.value = font;
          const mapping = getFontMapping(font);
          option.textContent = mapping.displayName;
          fontSelect.appendChild(option);
        });
        
        return Array.from(fonts);
      } catch (error) {
        console.error('åŠ è½½å­—ä½“åˆ—è¡¨å¤±è´¥:', error);
        // é™çº§åˆ°é»˜è®¤å­—ä½“åˆ—è¡¨
        const fontSelect = document.getElementById('customFont');
        fontSelect.innerHTML = `
          <option value="Alibaba PuHuiTi">Alibaba PuHuiTi (é˜¿é‡Œå·´å·´æ™®æƒ ä½“)</option>
          <option value="Source Han Sans">Source Han Sans (æ€æºé»‘ä½“)</option>
          <option value="Source Han Serif">Source Han Serif (æ€æºå®‹ä½“)</option>
        `;
        return ['Alibaba PuHuiTi', 'Source Han Sans', 'Source Han Serif'];
      }
    }
    
    // æ£€æµ‹å­—ä½“åŠ è½½çŠ¶æ€
    async function checkFontLoading() {
      const fontStatus = document.getElementById('fontStatus');
      
      try {
        // å…ˆåŠ è½½å­—ä½“åˆ—è¡¨
        const availableFonts = await loadAvailableFonts();
        
        // ä½¿ç”¨ Font Loading API æ£€æµ‹æ‰€æœ‰å­—ä½“
        if ('fonts' in document) {
          const loadPromises = availableFonts.map(font => 
            document.fonts.load(`16px "${font}"`)
          );
          
          await Promise.all(loadPromises);
          
          // æ£€æŸ¥æ¯ä¸ªå­—ä½“æ˜¯å¦çœŸçš„å¯ç”¨
          const loadedFonts = [];
          const failedFonts = [];
          
          for (const font of availableFonts) {
            const fontAvailable = document.fonts.check(`16px "${font}"`);
            if (fontAvailable) {
              loadedFonts.push(font);
            } else {
              failedFonts.push(font);
            }
          }
          
          if (failedFonts.length === 0) {
            fontStatus.className = 'font-status loaded';
            fontStatus.innerHTML = `âœ… æ‰€æœ‰å­—ä½“åŠ è½½æˆåŠŸï¼š${loadedFonts.join(', ')}`;
          } else if (loadedFonts.length > 0) {
            fontStatus.className = 'font-status loaded';
            fontStatus.innerHTML = `âš ï¸ éƒ¨åˆ†å­—ä½“åŠ è½½æˆåŠŸï¼š${loadedFonts.join(', ')}<br>æœªåŠ è½½ï¼š${failedFonts.join(', ')}`;
          } else {
            fontStatus.className = 'font-status error';
            fontStatus.innerHTML = 'âŒ å­—ä½“åŠ è½½å¤±è´¥ï¼šè¯·ç¡®ä¿å­—ä½“æ–‡ä»¶ä½äº ./fonts/ ç›®å½•ä¸‹';
          }
        } else {
          // é™çº§æ–¹æ¡ˆï¼šç­‰å¾…ä¸€æ®µæ—¶é—´åå‡è®¾åŠ è½½æˆåŠŸ
          setTimeout(() => {
            fontStatus.className = 'font-status loaded';
            fontStatus.innerHTML = 'âš ï¸ æµè§ˆå™¨ä¸æ”¯æŒå­—ä½“æ£€æµ‹ APIï¼Œå‡è®¾å­—ä½“å·²åŠ è½½';
          }, 1000);
        }
      } catch (error) {
        fontStatus.className = 'font-status error';
        fontStatus.innerHTML = 'âŒ å­—ä½“åŠ è½½å‡ºé”™ï¼š' + error.message;
      }
    }
    
    // é¡µé¢åŠ è½½æ—¶æ£€æµ‹å­—ä½“
    window.addEventListener('load', checkFontLoading);
    
    // æ ‡å‡†æµ‹è¯•æ–‡æœ¬é›†åˆ
    const standardTexts = {
      // çº¯è‹±æ–‡ï¼ˆæ— ç©ºæ ¼ï¼‰
      pureEnglish: 'HelloWorld',
      // çº¯è‹±æ–‡ï¼ˆå¸¦ç©ºæ ¼ï¼‰
      englishWithSpaces: 'Hello World',
      // çº¯è‹±æ–‡ï¼ˆå¸¦æ ‡ç‚¹ï¼‰
      englishWithPunctuation: 'Hello, World!',
      // è‹±æ–‡å¥å­
      englishSentence: 'The quick brown fox jumps over the lazy dog.',
      // çº¯ä¸­æ–‡ï¼ˆæ— æ ‡ç‚¹ï¼‰
      pureChinese: 'ä½ å¥½ä¸–ç•Œ',
      // çº¯ä¸­æ–‡ï¼ˆå¸¦æ ‡ç‚¹ï¼‰
      chineseWithPunctuation: 'ä½ å¥½ï¼Œä¸–ç•Œï¼',
      // ä¸­æ–‡å¥å­
      chineseSentence: 'ä»Šå¤©å¤©æ°”çœŸä¸é”™ï¼Œé€‚åˆå‡ºå»èµ°èµ°ã€‚',
      // ä¸­è‹±æ··æ’ï¼ˆæ— æ ‡ç‚¹ï¼‰
      mixed: 'Helloä½ å¥½World',
      // ä¸­è‹±æ··æ’ï¼ˆå¸¦ç©ºæ ¼ï¼‰
      mixedWithSpaces: 'Hello ä½ å¥½ World',
      // ä¸­è‹±æ··æ’ï¼ˆå¸¦æ ‡ç‚¹ï¼‰
      mixedWithPunctuation: 'Hello, ä½ å¥½ï¼World.',
      // æ•°å­—
      numbers: '0123456789',
      // æ•°å­—ä¸æ–‡æœ¬
      numbersWithText: 'Price: $123.45',
      // ç‰¹æ®Šå­—ç¬¦
      specialChars: '!@#$%^&*()_+-=[]{}|;:,.<>?',
      // emoji
      emoji: 'ğŸ˜€ğŸ˜ƒğŸ˜„ğŸ˜',
      // ä¸­è‹±æ•°å­—æ··åˆ
      comprehensive: 'Productä»·æ ¼: $99.99å…ƒ',
    };
    
    // æ ‡å‡†å­—å·
    const standardFontSizes = [12, 16, 24, 48];
    
    // åŠ¨æ€ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹ï¼ˆåŸºäºå·²åŠ è½½çš„å­—ä½“ï¼‰
    function generateTestCases() {
      const cases = [];
      
      // è·å–æ‰€æœ‰å·²åŠ è½½çš„å­—ä½“
      const fonts = Array.from(document.getElementById('customFont').options).map(opt => opt.value);
      
      fonts.forEach(font => {
        // ä¸ºæ¯ä¸ªå­—ä½“ç”Ÿæˆæ ‡å‡†æµ‹è¯•ç”¨ä¾‹
        standardFontSizes.forEach(fontSize => {
          // åŸºç¡€æµ‹è¯•ï¼ˆå¸¸ç”¨åœºæ™¯ï¼‰
          cases.push({
            name: `${font} [${fontSize}px] - çº¯è‹±æ–‡å¸¦ç©ºæ ¼`,
            text: standardTexts.englishWithSpaces,
            style: { fontFamily: font, fontSize, fontWeight: 400 }
          });
          
          cases.push({
            name: `${font} [${fontSize}px] - çº¯è‹±æ–‡å¸¦æ ‡ç‚¹`,
            text: standardTexts.englishWithPunctuation,
            style: { fontFamily: font, fontSize, fontWeight: 400 }
          });
          
          cases.push({
            name: `${font} [${fontSize}px] - çº¯ä¸­æ–‡`,
            text: standardTexts.pureChinese,
            style: { fontFamily: font, fontSize, fontWeight: 400 }
          });
          
          cases.push({
            name: `${font} [${fontSize}px] - çº¯ä¸­æ–‡å¸¦æ ‡ç‚¹`,
            text: standardTexts.chineseWithPunctuation,
            style: { fontFamily: font, fontSize, fontWeight: 400 }
          });
          
          cases.push({
            name: `${font} [${fontSize}px] - ä¸­è‹±æ··æ’å¸¦ç©ºæ ¼`,
            text: standardTexts.mixedWithSpaces,
            style: { fontFamily: font, fontSize, fontWeight: 400 }
          });
          
          // ä»…åœ¨ 16px æ—¶æµ‹è¯•æ›´å¤šåœºæ™¯ï¼ˆé¿å…æµ‹è¯•ç”¨ä¾‹è¿‡å¤šï¼‰
          if (fontSize === 16) {
            cases.push({
              name: `${font} [${fontSize}px] - çº¯è‹±æ–‡æ— ç©ºæ ¼`,
              text: standardTexts.pureEnglish,
              style: { fontFamily: font, fontSize, fontWeight: 400 }
            });
            
            cases.push({
              name: `${font} [${fontSize}px] - è‹±æ–‡å¥å­`,
              text: standardTexts.englishSentence,
              style: { fontFamily: font, fontSize, fontWeight: 400 }
            });
            
            cases.push({
              name: `${font} [${fontSize}px] - ä¸­æ–‡å¥å­`,
              text: standardTexts.chineseSentence,
              style: { fontFamily: font, fontSize, fontWeight: 400 }
            });
            
            cases.push({
              name: `${font} [${fontSize}px] - ä¸­è‹±æ··æ’å¸¦æ ‡ç‚¹`,
              text: standardTexts.mixedWithPunctuation,
              style: { fontFamily: font, fontSize, fontWeight: 400 }
            });
            
            cases.push({
              name: `${font} [${fontSize}px] - æ•°å­—`,
              text: standardTexts.numbers,
              style: { fontFamily: font, fontSize, fontWeight: 400 }
            });
            
            cases.push({
              name: `${font} [${fontSize}px] - æ•°å­—ä¸æ–‡æœ¬`,
              text: standardTexts.numbersWithText,
              style: { fontFamily: font, fontSize, fontWeight: 400 }
            });
            
            cases.push({
              name: `${font} [${fontSize}px] - ç‰¹æ®Šå­—ç¬¦`,
              text: standardTexts.specialChars,
              style: { fontFamily: font, fontSize, fontWeight: 400 }
            });
            
            cases.push({
              name: `${font} [${fontSize}px] - ç»¼åˆæµ‹è¯•`,
              text: standardTexts.comprehensive,
              style: { fontFamily: font, fontSize, fontWeight: 400 }
            });
          }
        });
      });
      
      return cases;
    }
    
    // åˆå§‹æµ‹è¯•ç”¨ä¾‹ï¼ˆåœ¨å­—ä½“åŠ è½½å®Œæˆå‰ä½¿ç”¨ï¼‰
    let testCases = [];

    // å­—ä½“çš„å®Œæ•´ metrics æ˜ å°„ï¼ˆä¸ä»£ç åº“ä¿æŒä¸€è‡´ï¼‰
    const fontMetrics = {
      'Alibaba PuHuiTi': { 
        ascender: 1060, 
        descender: -340,
        lineGap: 0,
        unitsPerEm: 1000 
      },
      'Source Han Sans': { 
        ascender: 880, 
        descender: -120,
        lineGap: 500,
        unitsPerEm: 1000 
      },
      'Source Han Serif': { 
        ascender: 1151, 
        descender: -286,
        lineGap: 0,
        unitsPerEm: 1000 
      },
      'LXGW WenKai': { 
        ascender: 928, 
        descender: -256,
        lineGap: 0,
        unitsPerEm: 1000 
      },
      '851tegakizatsu': { 
        ascender: 880, 
        descender: -144,
        lineGap: 0,
        unitsPerEm: 1024 
      },
    };

    async function measureText(text, style) {
      // ç­‰å¾…å­—ä½“åŠ è½½å®Œæˆ
      if ('fonts' in document) {
        try {
          await document.fonts.load(`${style.fontWeight || 400} ${style.fontSize}px "${style.fontFamily}"`);
        } catch (e) {
          console.warn('å­—ä½“åŠ è½½å¤±è´¥:', e);
        }
      }
      
      const div = document.createElement('div');
      div.style.position = 'absolute';
      div.style.visibility = 'hidden';
      div.style.whiteSpace = 'nowrap';
      div.style.fontFamily = `"${style.fontFamily}"`;
      div.style.fontSize = style.fontSize + 'px';
      div.style.fontWeight = style.fontWeight;
      div.style.letterSpacing = (style.letterSpacing || 0) + 'px';
      div.style.wordSpacing = (style.wordSpacing || 0) + 'px';
      div.textContent = text;
      
      // ç¡®ä¿æ²¡æœ‰å…¶ä»–æ ·å¼å¹²æ‰°
      div.style.padding = '0';
      div.style.margin = '0';
      div.style.border = 'none';
      div.style.boxSizing = 'content-box';
      
      document.body.appendChild(div);
      const rect = div.getBoundingClientRect();
      const computedStyle = window.getComputedStyle(div);
      
      // è·å–å­—ä½“ metrics
      const metrics = fontMetrics[style.fontFamily];
      const fontSize = style.fontSize;
      
      // è®¡ç®—é«˜åº¦ï¼ˆä½¿ç”¨å­—ä½“ metricsï¼Œä¸ä»£ç åº“ä¿æŒä¸€è‡´ï¼‰
      let height;
      if (metrics) {
        const { ascender, descender, lineGap = 0 } = metrics;
        const totalHeight = ascender - descender + lineGap;
        height = (totalHeight / metrics.unitsPerEm) * fontSize;
      } else {
        // é™çº§ï¼šä½¿ç”¨æµè§ˆå™¨å®é™…æ¸²æŸ“é«˜åº¦
        height = rect.height;
      }
      
      // è®¡ç®— baselineï¼ˆä½¿ç”¨å­—ä½“çš„ ascender æ¯”ä¾‹ï¼‰
      let baseline;
      if (metrics) {
        baseline = fontSize * (metrics.ascender / metrics.unitsPerEm);
      } else {
        // å¦‚æœæ²¡æœ‰å­—ä½“æ•°æ®ï¼Œä½¿ç”¨é€šç”¨ä¼°ç®—å€¼
        baseline = fontSize * 0.8;
      }
      
      // è·å–è®¡ç®—åçš„è¡Œé«˜
      let lineHeight = parseFloat(computedStyle.lineHeight);
      
      // å¦‚æœ lineHeight æ˜¯ 'normal'ï¼ŒparseFloat ä¼šè¿”å› NaN
      // è¿™ç§æƒ…å†µä¸‹ä½¿ç”¨è®¡ç®—çš„é«˜åº¦
      if (isNaN(lineHeight)) {
        lineHeight = height;
      }
      
      document.body.removeChild(div);
      
      return {
        width: rect.width,
        height: height,
        actualHeight: rect.height,
        lineHeight: lineHeight,
        baseline: baseline,
      };
    }

    async function testCustom() {
      const text = document.getElementById('customText').value;
      const fontFamily = document.getElementById('customFont').value;
      const fontSize = parseInt(document.getElementById('customSize').value);
      const fontWeight = parseInt(document.getElementById('customWeight').value);
      
      const result = await measureText(text, { fontFamily, fontSize, fontWeight });
      
      // ä¿å­˜å½“å‰æµ‹è¯•ç»“æœä¾›ç”Ÿæˆä»£ç ä½¿ç”¨
      window.currentCustomTest = {
        text,
        style: { fontFamily, fontSize, fontWeight },
        measured: result
      };
      
      const resultDiv = document.getElementById('customResult');
      resultDiv.innerHTML = `
        <div class="test-item">
          <div class="measurement-box" style="font-family: '${fontFamily}'; font-size: ${fontSize}px; font-weight: ${fontWeight};">
            ${text}
          </div>
          <div class="results">
            <div><strong>å­—ä½“:</strong> ${fontFamily}</div>
            <div><strong>æ–‡æœ¬:</strong> "${text}"</div>
            <div><strong>å®½åº¦:</strong> ${result.width.toFixed(2)}px</div>
            <div><strong>é«˜åº¦ (è®¡ç®—):</strong> ${result.height.toFixed(2)}px</div>
            <div><strong>é«˜åº¦ (æµè§ˆå™¨å®é™…):</strong> ${result.actualHeight.toFixed(2)}px ${Math.abs(result.height - result.actualHeight) < 1 ? 'âœ…' : 'âš ï¸ å·®å¼‚: ' + (result.actualHeight - result.height).toFixed(2) + 'px'}</div>
            <div><strong>è¡Œé«˜:</strong> ${result.lineHeight.toFixed(2)}px</div>
            <div><strong>åŸºçº¿:</strong> ${result.baseline.toFixed(2)}px (ä»é¡¶éƒ¨åˆ°åŸºçº¿çš„è·ç¦»)</div>
          </div>
          <div style="margin-top: 10px; padding: 10px; background: #e3f2fd; border-radius: 4px;">
            <strong>å¿«é€Ÿæµ‹è¯•ä»£ç :</strong>
            <pre style="margin: 5px 0;">const metrics = measureText('${text}', {
  fontFamily: '${fontFamily}',
  fontSize: ${fontSize},
  fontWeight: ${fontWeight},
});

expect(metrics.width).toBeCloseTo(${result.width.toFixed(2)}, 1);
expect(metrics.height).toBeCloseTo(${result.height.toFixed(2)}, 1);</pre>
          </div>
        </div>
      `;
    }
    
    // ä»å½“å‰è‡ªå®šä¹‰æµ‹è¯•ç”Ÿæˆå®Œæ•´æµ‹è¯•ä»£ç 
    function generateTestCodeFromCustom() {
      if (!window.currentCustomTest) {
        alert('è¯·å…ˆè¿è¡Œè‡ªå®šä¹‰æµ‹è¯•ï¼');
        return;
      }
      
      const r = window.currentCustomTest;
      const { fontFamily, fontSize, fontWeight } = r.style;
      
      const mapping = getFontMapping(fontFamily);
      
      const styleName = weightToStyle[fontWeight] || 'Regular';
      const importVarName = `${mapping.varName}${styleName}`;
      
      // ç”Ÿæˆå¯¼å…¥è¯­å¥
      const imports = `import { describe, expect, it, beforeAll } from 'vitest';
import { measureText, registerFont } from '../src';
import ${importVarName} from '../src/fonts/${mapping.fileName}-${styleName}';

beforeAll(() => {
  // æ³¨å†Œå­—ä½“
  registerFont(${importVarName});
});
`;
      
      // ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹ï¼ˆä¸‰å±‚ç»“æ„ï¼‰
      const styleProps = [];
      styleProps.push(`fontFamily: '${fontFamily}'`);
      styleProps.push(`fontSize: ${fontSize}`);
      if (fontWeight !== 400) styleProps.push(`fontWeight: ${fontWeight}`);
      
      const testCase = `describe('${fontFamily}', () => {
  describe('[${fontSize}px] [${fontWeight}]', () => {
    it('"${r.text}"', () => {
      const metrics = measureText('${r.text}', {
        ${styleProps.join(',\n        ')}
      });

      // æµè§ˆå™¨å®é™…æµ‹é‡å€¼ (from test-browser/index.html)
      expect(metrics.width).toBeCloseTo(${r.measured.width.toFixed(2)}, 1);
      expect(metrics.height).toBeCloseTo(${r.measured.height.toFixed(2)}, 1);
    });
  });
});`;
      
      const fullCode = imports + '\n' + testCase;
      document.getElementById('output').textContent = fullCode;
    }

    async function runAllTests() {
      // ç”Ÿæˆæ ‡å‡†åŒ–æµ‹è¯•ç”¨ä¾‹
      testCases = generateTestCases();
      
      if (testCases.length === 0) {
        alert('æ²¡æœ‰å¯ç”¨çš„å­—ä½“ï¼Œè¯·ç¡®ä¿å­—ä½“å·²åŠ è½½ï¼');
        return;
      }
      
      const results = [];
      for (const testCase of testCases) {
        const result = await measureText(testCase.text, testCase.style);
        results.push({
          ...testCase,
          measured: result
        });
      }
      
      const resultsDiv = document.getElementById('testResults');
      resultsDiv.innerHTML = `<div style="margin-bottom: 10px; color: #666;">
        <strong>å…± ${results.length} ä¸ªæµ‹è¯•ç”¨ä¾‹</strong>
      </div>` + results.map(r => `
        <div class="test-case">
          <h3>${r.name}</h3>
          <div class="measurement-box" style="font-family: '${r.style.fontFamily}'; font-size: ${r.style.fontSize}px; font-weight: ${r.style.fontWeight};">
            ${r.text}
          </div>
          <div class="results">
            <div><strong>å­—ä½“:</strong> ${r.style.fontFamily}</div>
            <div><strong>æ–‡æœ¬:</strong> "${r.text}"</div>
            <div><strong>å­—å·:</strong> ${r.style.fontSize}px</div>
            <div><strong>å­—é‡:</strong> ${r.style.fontWeight}</div>
            <div><strong>å®½åº¦:</strong> ${r.measured.width.toFixed(2)}px</div>
            <div><strong>é«˜åº¦ (è®¡ç®—):</strong> ${r.measured.height.toFixed(2)}px</div>
            <div><strong>é«˜åº¦ (æµè§ˆå™¨):</strong> ${r.measured.actualHeight.toFixed(2)}px ${Math.abs(r.measured.height - r.measured.actualHeight) < 1 ? 'âœ…' : 'âš ï¸'}</div>
            <div><strong>è¡Œé«˜:</strong> ${r.measured.lineHeight.toFixed(2)}px</div>
            <div><strong>åŸºçº¿:</strong> ${r.measured.baseline.toFixed(2)}px</div>
          </div>
        </div>
      `).join('');
      
      // ä¿å­˜ç»“æœä¾›ç”Ÿæˆä»£ç ä½¿ç”¨
      window.testResults = results;
    }

    function generateTestCode() {
      if (!window.testResults) {
        alert('è¯·å…ˆè¿è¡Œæµ‹è¯•ï¼');
        return;
      }
      
      // æŒ‰å­—ä½“åˆ†ç»„ï¼Œç„¶åæŒ‰å­—å·+å­—é‡åˆ†ç»„
      const fontGroups = {};
      window.testResults.forEach(r => {
        const font = r.style.fontFamily || 'default';
        const size = r.style.fontSize || 16;
        const weight = r.style.fontWeight || 400;
        
        if (!fontGroups[font]) {
          fontGroups[font] = {};
        }
        
        const sizeWeightKey = `${size}|${weight}`;
        if (!fontGroups[font][sizeWeightKey]) {
          fontGroups[font][sizeWeightKey] = {
            size,
            weight,
            tests: []
          };
        }
        
        fontGroups[font][sizeWeightKey].tests.push(r);
      });
      
      // æ”¶é›†æ‰€æœ‰å”¯ä¸€çš„å­—ä½“+å­—é‡ç»„åˆï¼ˆç”¨äºå¯¼å…¥ï¼‰
      const uniqueFontWeights = new Set();
      Object.keys(fontGroups).forEach(font => {
        Object.values(fontGroups[font]).forEach(group => {
          uniqueFontWeights.add(`${font}|${group.weight}`);
        });
      });
      
      // ç”Ÿæˆå¯¼å…¥è¯­å¥
      const imports = `import { describe, expect, it, beforeAll } from 'vitest';
import { measureText, registerFont } from '../src';
${[...uniqueFontWeights].map(fontWeight => {
  const [font, weight] = fontWeight.split('|');
  const mapping = getFontMapping(font);
  const styleName = weightToStyle[weight] || 'Regular';
  const importVarName = `${mapping.varName}${styleName}`;
  return `import ${importVarName} from '../src/fonts/${mapping.fileName}-${styleName}';`;
}).join('\n')}

beforeAll(() => {
  // æ³¨å†Œå­—ä½“
${[...uniqueFontWeights].map(fontWeight => {
  const [font, weight] = fontWeight.split('|');
  const mapping = getFontMapping(font);
  const styleName = weightToStyle[weight] || 'Regular';
  const importVarName = `${mapping.varName}${styleName}`;
  return `  registerFont(${importVarName});`;
}).join('\n')}
});
`;
      
      // æŒ‰å­—ä½“ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹ï¼ˆä¸‰å±‚ç»“æ„ï¼‰
      const testGroups = Object.keys(fontGroups).map(font => {
        const sizeWeightGroups = fontGroups[font];
        
        // ç¬¬äºŒå±‚ï¼šæŒ‰å­—å·+å­—é‡åˆ†ç»„
        const nestedDescribes = Object.keys(sizeWeightGroups).map(sizeWeightKey => {
          const { size, weight, tests } = sizeWeightGroups[sizeWeightKey];
          
          // ç¬¬ä¸‰å±‚ï¼šæµ‹è¯•ç”¨ä¾‹
          const testCases = tests.map(r => {
            const styleProps = [];
            if (r.style.fontFamily) styleProps.push(`fontFamily: '${r.style.fontFamily}'`);
            if (r.style.fontSize) styleProps.push(`fontSize: ${r.style.fontSize}`);
            if (r.style.fontWeight && r.style.fontWeight !== 400) styleProps.push(`fontWeight: ${r.style.fontWeight}`);
            
            return `    it('"${r.text}"', () => {
      const metrics = measureText('${r.text}', {
        ${styleProps.join(',\n        ')}
      });

      // æµè§ˆå™¨å®é™…æµ‹é‡å€¼ (from test-browser/index.html)
      expect(metrics.width).toBeCloseTo(${r.measured.width.toFixed(2)}, 1);
      expect(metrics.height).toBeCloseTo(${r.measured.height.toFixed(2)}, 1);
    });`;
          }).join('\n\n');
          
          return `  describe('[${size}px] [${weight}]', () => {
${testCases}
  });`;
        }).join('\n\n');
        
        // ç¬¬ä¸€å±‚ï¼šæŒ‰å­—ä½“åˆ†ç»„
        return `describe('${font}', () => {
${nestedDescribes}
});`;
      }).join('\n\n');
      
      const fullCode = imports + '\n' + testGroups;
      document.getElementById('output').textContent = fullCode;
    }
    
    // å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿
    function copyOutputToClipboard() {
      const output = document.getElementById('output');
      const text = output.textContent;
      
      if (!text || text.trim() === '') {
        alert('æ²¡æœ‰å¯å¤åˆ¶çš„ä»£ç ï¼Œè¯·å…ˆè¿è¡Œæµ‹è¯•å¹¶ç”Ÿæˆä»£ç ï¼');
        return;
      }
      
      navigator.clipboard.writeText(text).then(() => {
        // æ˜¾ç¤ºå¤åˆ¶æˆåŠŸæç¤º
        const feedback = document.getElementById('copyFeedback');
        feedback.classList.add('show');
        setTimeout(() => {
          feedback.classList.remove('show');
        }, 2000);
      }).catch(err => {
        // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨ä¼ ç»Ÿæ–¹æ³•
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.left = '-999999px';
        document.body.appendChild(textArea);
        textArea.select();
        try {
          document.execCommand('copy');
          const feedback = document.getElementById('copyFeedback');
          feedback.classList.add('show');
          setTimeout(() => {
            feedback.classList.remove('show');
          }, 2000);
        } catch (err) {
          alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶ä»£ç ');
        }
        document.body.removeChild(textArea);
      });
    }
  </script>
</body>
</html>
